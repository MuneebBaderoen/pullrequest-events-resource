#! /usr/bin/env node

const {getStdinAsJson, getSourceConfig} = require('./common.js')
const fetch = require('node-fetch')
const { ApolloClient } = require('apollo-client')
const { HttpLink } = require('apollo-link-http');
const { InMemoryCache } = require('apollo-cache-inmemory');
const gql = require('graphql-tag');




/**
 * This function makes the graphql request to fetch the most recent 10 pull requests
 * That have been merged
 * @param stdinConfig stdin parsed as json, passed in by the concourse runtime
 */
async function getMergedPullRequests(stdinConfig) {

  // use only the 
  let sourceConfig = stdinConfig.source


  // params necessary for request
  const graphqlApi = sourceConfig["graphql_api"]
  const accessToken = sourceConfig["access_token"]
  const baseBranch = sourceConfig["base_branch"]
  const owner = sourceConfig["owner"]
  const repo = sourceConfig["repo"]
  const first = sourceConfig["first"]
  const states = sourceConfig["states"]


  // if a version was passed in, set .cursor as after
  // to grab only the versions after the cursor
  let after = undefined;
  if (stdinConfig["version"]) {
    after = stdinConfig["version"].cursor
  }
  

  // setup the client
  const client = new ApolloClient({
    link: new HttpLink({
      uri: graphqlApi,
      fetch: fetch,
      headers: {
        authorization: "Bearer " + accessToken
      }
    }),
    cache: new InMemoryCache()
  });


  const closedPrQuery = gql`
    query RecentlyMergedOrClosedPullRequests(
      $owner: String!, 
      $repo: String!, 
      $baseBranch: String!, 
      $first: Int!,
      $after: String,
      $states: [PullRequestState!]!
    ) {
      repository(owner: $owner, name: $repo) {
        nameWithOwner
        url 
        pullRequests(
          first: $first,
          baseRefName: $baseBranch, 
          states: $states, 
          orderBy:{field:UPDATED_AT, direction:ASC},
          after: $after
        ) {
          edges {
            cursor
            node{
              id
              number
              url
              baseRefName
              headRefName
              merged
              closed
              mergedAt
              closedAt
            }
          }
        }
      }
    }
  `;

  let resp = await client.query({
    query: closedPrQuery,
    variables: {
      owner,
      repo,
      baseBranch,
      first,
      after,
      states
    }
  });

  return resp.data.repository.pullRequests.edges

}



/**
 * Returns a list of versions
 * @param pullRequests array of pull request objects returned from graphql query
 */
function convertToVersions(pullRequests) {

  let versions = [];

  for (let pr of pullRequests) {

    // since this resource only checks MERGED or CLOSED
    // if it isn't merged, then it will be closed
    let finalState = pr.node.merged ? 'MERGED' : 'CLOSED'

    versions.push({
      id: pr.node.id,
      cursor: pr.cursor,
      number: pr.node.number.toString(),
      url: pr.node.url,
      baseBranch: pr.node.baseRefName,
      headBranch: pr.node.headRefName,
      state: finalState,
      // if merged or closed will have either of these timestamps
      // merged prs have both merged and closed
      timestamp: pr.node.mergedAt || pr.node.closedAt
    })
  }

  return versions
}


/** 
 * This is the main function
 * Read source configuration from stdin and then runs a graphQL query
 * to fetch MERGED or CLOSED pull requests
*/
async function check() {

  console.error("Checking for pull request events...")
  stdinJson = await getStdinAsJson()
  finalConfig = await getSourceConfig(stdinJson)
  pullRequests = await getMergedPullRequests(finalConfig)
  resultingVersions = convertToVersions(pullRequests)

  // if a version was given, concat the resulting versions
  // as per concourse resource spec
  if (finalConfig.version) {
    resultingVersions = [finalConfig.version].concat(resultingVersions)
  }


  // output the resulting versions to stdout for consumption by concourse
  console.log(JSON.stringify(resultingVersions))
}


check()